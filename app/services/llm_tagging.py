import json
import time
import random
import asyncio
from typing import Dict, List, Optional, Set
from loguru import logger

try:
    from openai import OpenAI
    OPENAI_AVAILABLE = True
except ImportError:
    OPENAI_AVAILABLE = False
    logger.warning("OpenAI library not available, LLM service will use fallback mode")

from app.utils.config import config
from app.models.input_models import NoteInput, TagPrediction


# ==================== æœ‰æ•ˆç±»åˆ«è¯è¡¨ ====================
# æ¥æº: /Users/liuchao/AI/xhs_note_ctr_model/docs/taxonomy_knowledge.csv
# è¿™äº›è¯è¡¨ç”¨äºçº¦æŸLLMè¾“å‡ºï¼Œç¡®ä¿é¢„æµ‹ç»“æœå¯è¢«æ¨¡å‹æ­£ç¡®ç¼–ç 

VALID_INTENTION_LV1: Set[str] = {
    'äº¤æ˜“è¥é”€', 'åˆ†äº«', 'åˆ†äº«å…´è¶£çˆ±å¥½', 'åˆ†äº«å–œå¥½', 'åˆ†äº«å¤–åœ¨', 'åˆ†äº«æ„Ÿå—',
    'åˆ†äº«æ—¥å¸¸', 'åˆ†äº«æ˜æ˜Ÿ', 'æ¨è', 'æ±‚åŠ©', 'ç¤¾äº¤', 'ç»éªŒçŸ¥è¯†æ•™ç¨‹',
    'è¯„ä»·', 'èµ„æº/èµ„è®¯', 'è·Ÿé£æ¨¡ä»¿'
}

VALID_INTENTION_LV2: Set[str] = {
    'äº¤æ˜“è¥é”€', 'ä½é¾„ç¤¾äº¤', 'ä¿¡æ¯èµ„è®¯', 'å…´è¶£ç¤¾äº¤', 'åˆ†äº«', 'åˆ†äº«å…´è¶£çˆ±å¥½',
    'åˆ†äº«åˆ›ä½œ', 'åˆ†äº«å–œå¥½', 'åˆ†äº«å¤–åœ¨', 'åˆ†äº«æƒ…ç»ª', 'åˆ†äº«æ„Ÿæ‚Ÿ', 'åˆ†äº«æ—¥å¸¸',
    'åˆ†äº«ç»å†', 'åæ§½', 'æƒ…æ„Ÿäº¤å‹', 'æ‹åŒæ¬¾', 'æ¨èæµ‹è¯„', 'æ•™ç¨‹',
    'æ±‚äººå¸®å¿™', 'æ±‚æ„è§', 'çŸ¥è¯†ç§‘æ™®', 'ç¤¾äº¤', 'ç»éªŒæ”»ç•¥', 'éšæ‰‹æ‹'
}

VALID_TAXONOMY1: Set[str] = {
    'äºŒæ¬¡å…ƒ', 'äººæ–‡', 'ä½“è‚²è¿åŠ¨', 'å¥èº«å‡è‚¥', 'å…´è¶£çˆ±å¥½', 'å‡è‚¥', 'åŒ»ç–—å¥åº·',
    'å•†ä¸šè´¢ç»', 'åŸå¸‚å‡ºè¡Œ', 'å¨±ä¹', 'å©šå«', 'å® ç‰©', 'å®¶å±…å®¶è£…', 'å®¶å±…ç”¨å“',
    'å½±è§†', 'æƒ…æ„Ÿ', 'æˆ·å¤–', 'æç¬‘', 'æ‘„å½±', 'æ•™è‚²', 'æ—…æ¸¸', 'æ—¶å°š',
    'æ˜Ÿåº§å‘½ç†', 'æ¯å©´', 'æ±½è½¦', 'æ¸¸æˆ', 'æ½®æµ', 'ç”Ÿæ´»è®°å½•', 'çŸ¥è¯†',
    'ç¤¾ç§‘', 'ç§‘æŠ€æ•°ç ', 'ç´ æ', 'ç¾å¥³å¸…å“¥', 'ç¾å¦†', 'ç¾é£Ÿ', 'èŒåœº',
    'è‰ºæœ¯', 'èŒå¨ƒ', 'èµ„è®¯', 'è¿åŠ¨å¥èº«', 'éŸ³ä¹'
}

VALID_TAXONOMY2: Set[str] = {
    'k12æ•™è‚²', 'ä¸ªäººæŠ¤ç†', 'ä¸­å¤–ç”Ÿæ´»', 'ä¸­å­¦æ•™è‚²', 'ä¸»æœºæ¸¸æˆ', 'ä¹¦æ³•', 'äºŒæ‰‹è½¦',
    'äºŒæ¬¡å…ƒå…¶ä»–', 'äº§å“è®¾è®¡', 'äººåƒæ‘„å½±', 'äººæ–‡å…¶ä»–', 'ä½æ–™', 'ä½“æ€çŸ«æ­£',
    'ä½“è‚²è¿åŠ¨å…¶ä»–', 'ä¿å¥å“', 'å¥èº«å‡è‚¥å…¶ä»–', 'å¥èº«å¡‘å‹', 'å¥èº«é¥®é£Ÿ', 'å…”å­',
    'å…”ç±»', 'å…¬å›­', 'å…´è¶£çˆ±å¥½å…¶ä»–', 'å…¶ä»–åŸå¸‚å‡ºè¡Œ', 'å…¶ä»–æˆ·å¤–ä½“éªŒ', 'å…¶ä»–æé™è¿åŠ¨',
    'å…¶ä»–èµ›äº‹', 'å…»ç”Ÿé£Ÿç–—', 'å†™ä½œ', 'å†›äº‹', 'å†²æµª', 'å‡è‚¥', 'å‡è‚¥å¥åº·',
    'å‡è‚¥åŒ»è¯', 'å‡è‚¥åœºæ‰€', 'å‡ºè¡ŒVLOG', 'å‡ºè¡Œæ”»ç•¥', 'åˆ›æ„æ‘„å½±', 'å‰æ²¿è¶‹åŠ¿',
    'åŠ¨æ¼«', 'åŠ±å¿—é¸¡æ±¤', 'åŒ»ç–—å¥åº·å…¶ä»–', 'åŒ»ç–—å™¨æ¢°', 'åŒ»ç–—æ–¹æ³•', 'åŒ»ç–—è¯å“',
    'åŒ»ç¾æ•´å½¢', 'å†å²', 'å»å¤„', 'å‘å‹', 'åƒæ’­', 'åŒäººè¡ç”Ÿ', 'å“è´¨ç”Ÿæ´»',
    'å•®é½¿ç±»', 'å–‚å…»å·¥å…·', 'åŸå¸‚æ‘„å½±', 'å£çº¸', 'å¤§å­¦å­¦ä¹ ', 'å¤§å­¦æ•™è‚²', 'å¤´åƒ',
    'å¥½ç‰©æ¨è', 'å¦ˆå¦ˆç»éªŒ', 'å¨±ä¹å…¶ä»–', 'å¨±ç»¼è¯„è®º', 'å©šå«å…¶ä»–', 'å©šç¤¼åœºåœ°',
    'å©šç¤¼ç”¨å“', 'å©šç¤¼ç»éªŒ', 'å©šç¤¼è®°å½•', 'å©šç¤¼é€ å‹', 'å©´ç«¥å‡ºè¡Œ', 'å©´ç«¥å¯å±…',
    'å©´ç«¥æ—¶å°š', 'å©´ç«¥æ´—æŠ¤', 'å©´ç«¥ç©å…·', 'å©´ç«¥ç”¨å“', 'å©´ç«¥é£Ÿå“', 'å­•äº§ç»éªŒ',
    'å­•æœŸç©¿æ­', 'å­¦å‰æ•™è‚²', 'å®…ç©', 'å®å®å†™çœŸ', 'å®å®æ‰è‰º', 'å®å®æ—¥å¸¸',
    'å® ç‰©å…¶ä»–', 'å® ç‰©ç”¨å“', 'å®¤å†…ä¼‘é—²', 'å®¤å†…è®¾è®¡', 'å®¶å…·', 'å®¶å±…å®¶è£…å…¶ä»–',
    'å®¶å±…å®¶è£…åˆé›†', 'å®¶å±…ç”¨å“', 'å®¶å±…è£…é¥°', 'å®¶åº­', 'å®¶åº­æ•™è‚²', 'å®¶ç”¨ç”µå™¨',
    'å°å‰§åœº', 'å°å­¦æ•™è‚²', 'å±…å®¶å…´è¶£', 'å±…å®¶ç»éªŒ', 'å±•è§ˆ', 'å±±æ‘é‡é£Ÿ', 'å¸…å“¥',
    'å¹³é¢è®¾è®¡', 'å»ºç­‘', 'å½©å¦†', 'å½±è§†', 'å½±è§†å¨±ä¹å…¶ä»–', 'å½±è§†æ¨èï¼ˆè§†é¢‘ï¼‰',
    'å½±è§†æ··å‰ªï¼ˆè§†é¢‘ï¼‰', 'å½±è§†ç‰‡æ®µï¼ˆè§†é¢‘ï¼‰', 'å½±è§†èµ„è®¯ï¼ˆè§†é¢‘ï¼‰', 'å½±éŸ³å¨±ä¹',
    'å½±éŸ³æ™ºèƒ½', 'å¾’æ­¥', 'å¿ƒç†å­¦', 'æƒ…æ„Ÿå…¶ä»–', 'æƒ…æ„Ÿå¿ƒç†', 'æƒ…æ„Ÿæ•…äº‹', 'æƒ…æ„Ÿæ—¥å¸¸',
    'æƒ…æ„ŸçŸ¥è¯†', 'æˆå‰§', 'æˆäººç”¨å“', 'æˆ˜æœ¯è£…å¤‡ä½“éªŒ', 'æ‰‹å·¥', 'æ‰‹æœºå¹³æ¿', 'æ‰‹æœºæ¸¸æˆ',
    'æŠ¤è‚¤', 'æŒ‡ç©', 'æ¥åœ°æ°”ç”Ÿæ´»', 'æç¬‘å…¶ä»–', 'æ‘„å½±å…¶ä»–', 'æ‘„å½±å™¨æ', 'æ‘„å½±æŠ€å·§',
    'æ‘©æ‰˜è½¦', 'æ•™è‚²å…¶ä»–', 'æ•™è‚²åŸ¹è®­', 'æ•™è‚²æ—¥å¸¸', 'æ•°ç æ­é…', 'æ–‡å…·æ‰‹è´¦', 'æ–‡åŒ–',
    'æ–‡å­—ç´ æ', 'æ–‡ç©æ–‡åˆ›', 'æ–°èƒ½æºæ™ºèƒ½', 'æ—…å±…', 'æ—…æ¸¸å…¶ä»–', 'æ—…æ¸¸æ”»ç•¥',
    'æ—…æ¸¸æ±‚åŠ©ç»„é˜Ÿ', 'æ—…æ¸¸è®°å½•', 'æ—¥å¸¸ç‰‡æ®µ', 'æ—©æ•™', 'æ—¶å°šå…¶ä»–', 'æ˜†è™«ç±»',
    'æ˜æ˜Ÿå¨±ä¹èµ„è®¯', 'æ˜Ÿåº§', 'æ˜Ÿåº§å‘½ç†å…¶ä»–', 'æ™¯ç‚¹ä½“éªŒ', 'æ™ºèƒ½å®¶å±…', 'æ™ºèƒ½ç©¿æˆ´',
    'æé™è¿åŠ¨', 'æ ¡å›­æ•™è‚²', 'æ ¡å›­ç”Ÿæ´»', 'æ¥¼å¸‚èµ„è®¯', 'æ­£é¤', 'æ¯å©´å…¶ä»–', 'æ¯å©´æ—¥å¸¸',
    'æ°‘å®¿é…’åº—', 'æ°‘ç”Ÿæ–°é—»', 'æ°´ä¸Šæ´»åŠ¨', 'æ°´æ—ç±»', 'æ±½è½¦å…¶ä»–', 'æ±½è½¦æ”¹è£…', 'æ±½è½¦æ–‡åŒ–',
    'æ±½è½¦ç”Ÿæ´»', 'æ±½è½¦çŸ¥è¯†', 'æ±½è½¦ç§‘æ™®', 'æ²‰æµ¸å¼æ´»åŠ¨', 'æ³•å¾‹', 'æ¸¸æˆå…¶ä»–', 'æ¸¸æ³³',
    'æ»‘æ¿', 'æ»‘é›ª', 'æ¼”å”±ç¿»å”±', 'æ¼”å¥ç¿»å¼¹', 'æ½œæ°´', 'æ½®æµä¿¡æ¯', 'æ½®æµå…¶ä»–',
    'æ½®æµå‘å‹', 'æ½®æµæ´»åŠ¨', 'æ½®æµç©å…·', 'æ½®æµè‰ºæœ¯', 'æ½®æµèµ„è®¯', 'æ½®æµé…é¥°',
    'ç‡ƒè„‚èˆ', 'çˆ¬è¡Œä¸¤æ –', 'çˆ¬è¡Œç±»åŠ¨ç‰©', 'ç‰¹æ®Šæ‘„å½±', 'ç‹—', 'çŒ«', 'ç©å…·', 'ç©æœºæ”»ç•¥',
    'ç‘œä¼½', 'ç”Ÿæ´»å‰ªå½±', 'ç”Ÿæ´»ç§‘æ™®', 'ç”Ÿæ´»éšç¬”', 'ç”µå­ç«æŠ€', 'ç”µå½±ï¼ˆå›¾æ–‡ï¼‰', 'ç”µè„‘',
    'ç”µè§†ï¼ˆå›¾æ–‡ï¼‰', 'ç”·å£«ç†å®¹', 'ç•™å­¦æ•™è‚²', 'ç›Šæ™ºç©å…·', 'çœ‹è½¦é€‰ä¹°', 'çŸ¥è¯†ç§‘æ™®',
    'ç¡¬è£…', 'ç¤¾ç§‘äººæ–‡', 'ç¤¾ç§‘å…¶ä»–', 'ç§‘å­¦ç§‘æ™®', 'ç§‘æŠ€', 'ç§‘æŠ€æ•°ç å…¶ä»–', 'ç§¯æœ¨',
    'ç©¿æ­', 'ç©¿æ­ootd', 'ç®±åŒ…', 'ç¯®çƒ', 'ç´ æå…¶ä»–', 'ç´ æåˆ†äº«', 'çº¿ä¸‹æ¸¸æˆ', 'ç»˜ç”»',
    'ç»¼åˆä½“è‚²', 'ç»¼è‰ºæ··å‰ª', 'ç»¼è‰ºç‰‡æ®µ', 'ç»¼è‰ºï¼ˆå›¾æ–‡ï¼‰', 'ç½‘ç»œæ¸¸æˆ', 'ç¾å¥³',
    'ç¾å¥³å¸…å“¥å…¶ä»–', 'ç¾å¦†å…¶ä»–', 'ç¾å¦†åˆé›†', 'ç¾ç”²', 'ç¾é£ŸVLOG', 'ç¾é£Ÿå…¶ä»–',
    'ç¾é£Ÿå±•ç¤º', 'ç¾é£Ÿæ¢åº—', 'ç¾é£Ÿæ•™ç¨‹', 'ç¾é£Ÿæµ‹è¯„', 'èŒä¸šåŸ¹è®­', 'èŒä¸šè€ƒè¯•',
    'èŒåœºå…¶ä»–', 'èŒåœºå¹²è´§', 'èŒåœºè¡Œä¸š', 'è‚²å„¿ç»éªŒ', 'èƒ¶ç‰‡æ‘„å½±', 'è‡ªæ‹', 'èˆè¹ˆ',
    'è‰ºæœ¯', 'è‰ºæœ¯å…¶ä»–', 'è‰ºæœ¯æ´»åŠ¨', 'è‰ºæœ¯ç§‘æ™®', 'è‰ºæœ¯ç»˜ç”»', 'è‰ºæœ¯è®¾è®¡', 'èŒå¨ƒå…¶ä»–',
    'è¡¨æƒ…åŒ…', 'è§†é¢‘ç´ æ', 'è¯­è¨€æ•™è‚²', 'è´¢ç»è§£è¯»', 'è´­ç‰©', 'èµ„è®¯å…¶ä»–', 'è¶³çƒ',
    'è·‘æ­¥', 'è·³ç»³', 'è½¦è½½å¥½ç‰©', 'è½¯ä»¶æœåŠ¡', 'è¿åŠ¨', 'é€šè¯†æ•™è‚²', 'é“è·¯äº¤é€š', 'é…é¥°',
    'é‡ç”ŸåŠ¨ç‰©', 'é‡‘èç†è´¢', 'é’“é±¼', 'é˜…è¯»', 'éœ²è¥', 'é™ç‰©æ‘„å½±', 'éé…’ç²¾ç±»é¥®æ–™',
    'é‹å±¥', 'é‹é´', 'éŸ³ä¹', 'éŸ³ä¹å…¶ä»–', 'éŸ³ä¹åˆ†äº«', 'éŸ³ä¹æ¼”å‡º', 'é£å…‰æ‘„å½±', 'é£ç›˜',
    'é£Ÿè°±', 'é¦™æ°´', 'é©¾è€ƒå­¦è½¦', 'éª‘è¡Œ', 'é¸Ÿç±»', 'é¸Ÿç±»åŠ¨ç‰©'
}

VALID_TAXONOMY3: Set[str] = {
    'Cosplay', 'IPåŠ¨æ¼«', 'JK', 'Lolita', 'UIè®¾è®¡', 'ä¸Šè¡£', 'ä¸“ä¸šå­¦ç§‘', 'ä¸“å‡æœ¬',
    'ä¸ªäººå†™çœŸ', 'ä¸ªäººæŠ¤ç†å…¶ä»–', 'ä¸ªäººè®¾å®š', 'ä¸­å­¦æ•™è‚²', 'ä¸­å¼å·¥è‰ºå’Œç”Ÿæ´»', 'ä¸»æœºæ¸¸æˆç”»é¢',
    'ä¸»æœºè®¾å¤‡é…ä»¶', 'ä¸»é¢˜ä¹å›­', 'ä¹å™¨æ•™å­¦', 'ä¹å™¨æ¼”å¥', 'ä¹è°±åˆ†äº«', 'ä¹¦ä¸ç”Ÿæ´»', 'ä¹¦åº—ä½“éªŒ',
    'ä¹¦æ³•æ‰‹å†™', 'ä¹°æ‰‹åº—', 'ä¹³æ¶²', 'äºŒæ‰‹è½¦', 'äº¤è§„ç§‘æ™®', 'äº¤é€šå·¥å…·', 'äº¤é€šç­¾è¯æ”»ç•¥',
    'äº§å“è®¾è®¡', 'äº²æƒ…æ•…äº‹', 'äº²æƒ…æ—¥å¸¸', 'äººæ–‡æ™¯ç‚¹', 'äººç”Ÿæ•…äº‹', 'ä»“é¼ ', 'ä¼‘é—²å¨±ä¹å…¶ä»–',
    'ä¼‘é—²å¨±ä¹æ”»ç•¥', 'ä¼ ç»Ÿæ™¯ç‚¹æ”»ç•¥', 'ä½å®¿æ”»ç•¥', 'ä½“æ€çŸ«æ­£æ•™ç¨‹', 'ä½“æ€çŸ«æ­£è¯„æµ‹', 'ä¿®å›¾æŠ€å·§',
    'å¥èº«å…¶ä»–', 'å¥èº«æ•™ç¨‹', 'å¥èº«ç»éªŒ', 'å¥èº«è¯„æµ‹', 'å…¨å±‹æ™ºèƒ½', 'å…¶ä»–å®¤å†…ä¼‘é—²', 'å…¶ä»–å°è¯­ç§',
    'å…¶ä»–å±•è§ˆ', 'å…¶ä»–å¾’æ­¥', 'å…¶ä»–æ”»ç•¥', 'å…¶ä»–æ°´ä¸Šæ´»åŠ¨', 'å…¶ä»–æ»‘æ¿', 'å…¶ä»–æ»‘é›ª', 'å…¶ä»–ç†å®¹',
    'å…¶ä»–çº¿ä¸‹æ¸¸æˆ', 'å…¶ä»–ç¾é£Ÿæ•™ç¨‹', 'å…¶ä»–ç¾é£Ÿæµ‹è¯„', 'å…¶ä»–è´­ç‰©ä½“éªŒ', 'å…¶ä»–è½¦å‹', 'å…¶ä»–é‹',
    'å…»æŠ¤ç»´ä¿®', 'å…»ç‹—ç»éªŒ', 'å…»çŒ«ç»éªŒ', 'å†…è¡£', 'å†…é¥°ä»‹ç»', 'å†¥æƒ³', 'å†²æµª', 'å‡‰é‹',
    'å‡è‚¥å…¶ä»–', 'å‡è‚¥åŒ»ç¾', 'å‡è‚¥åŒ»è¯', 'å‡è‚¥åœºæ‰€', 'å‡è‚¥æ•™ç¨‹', 'å‡è‚¥ç»éªŒ', 'å‡è‚¥è¯å“',
    'å‡è‚¥è¯„æµ‹', 'å‡è‚¥é¤æ•™ç¨‹', 'å‡è„‚é¥®é£Ÿ', 'å‡ºç‰ˆè®¾è®¡', 'åˆ€å·¥æ•™ç¨‹', 'åˆ’èˆ¹', 'åˆ›æ„ç¾é£Ÿå±•ç¤º',
    'å‰æ²¿æ–°å“', 'å‰§æœ¬æ€', 'å‰ªè¾‘æŠ€å·§', 'åŠå…¬è®¾å¤‡', 'åŠ¨æ¼«äº¤æµ', 'åŠ¨æ¼«å°å‰§åœº', 'åŠ¨æ¼«ç´ æ',
    'åŠ¨æ¼«é€Ÿè§ˆ', 'åŠ¨ç‰©å›­', 'åŠ¨ç‰©ç§‘æ™®', 'åŒ…åŒ…é…é¥°', 'åŒ–å¦†å·¥å…·', 'åŒ–å¦†æ°´', 'åè¯­å‰§', 'åè¯­ç”µå½±',
    'å•å“æ¨è', 'å•æœºæ¸¸æˆ', 'å•è‚©åŒ…', 'å•é‹', 'å¡ç‰Œ', 'å§å®¤', 'å«ç”Ÿé—´', 'å¸å¦†', 'å¨æˆ¿',
    'å¨æˆ¿å®¶ç”µ', 'å»å¤„å…¶ä»–', 'åŒè‚©åŒ…', 'å‘çƒ§è€³æœº', 'å£è…”æŠ¤ç†', 'åˆé›†ç±»æ”»ç•¥', 'åŒäººå›¾',
    'åŒäººæ–‡', 'å’–å•¡', 'å“ç‰Œ', 'å“ç‰Œè®¾è®¡', 'å”‡å¦†', 'å”‡éƒ¨æŠ¤ç†', 'å”±ç‰‡åˆ†äº«', 'å•†å“é›¶é£Ÿ',
    'å•†åœº', 'å•®é½¿å…¶ä»–', 'å–œå‰§ç°åœº', 'å››å…­çº§', 'å›­è‰º', 'å›´å·¾', 'å›½å†…ç»¼è‰º', 'å›½å¤–ç»¼è‰º',
    'å›½é£ç»˜ç”»', 'åœ°æ–¹æ–¹è¨€', 'åœ°çƒç§‘å­¦', 'åŸå¸‚å…¬å›­', 'åŸé•‡ä¹¡æ‘', 'å¢è‚Œå¡‘å½¢é¥®é£Ÿ', 'å£çº¸',
    'å¤–å›½äººVLOG', 'å¤–æ–‡åŸè‘—', 'å¤–è¯­ç”µå½±', 'å¤šå…ƒèŒä¸š', 'å¤šæ™¯ç‚¹VLOG', 'å¤šç±»ç›®åˆé›†', 'å¤§å‹å®¶å…·',
    'å¤§å­¦å­¦ä¹ ', 'å¤§å­¦å­¦ä¹ å…¶ä»–', 'å¤§å­¦æ•™è‚²å…¶ä»–', 'å¤§å®¶ç”µ', 'å¤©æ–‡å®‡å®™', 'å¤´åƒ', 'å¤´å‘äº§å“',
    'å¥³æ€§æŠ¤ç†', 'å¥¶èŒ¶', 'å©šå§»å’¨è¯¢', 'å­—ä½“è®¾è®¡', 'å­¦ä¹ å·¥å…·', 'å­¦ä¹ æ–¹æ³•', 'å­¦ä¹ ç¬”è®°',
    'å­¦å‰æ•™è‚²', 'å­¦ç§‘æ•™è‚²', 'å®…è‰º', 'å® ç‰©ç”¨å“å…¶ä»–', 'å®¢å…', 'å®¤å†…é¡¹ç›®', 'å®¤å¤–é¡¹ç›®',
    'å®¶å…·å…¶ä»–', 'å®¶å±…DIY', 'å®¶å±…æ”¶çº³', 'å®¶å±…æ¸…æ´', 'å®¶å±…ç”¨å“å…¶ä»–', 'å®¶å±…è£…é¥°å…¶ä»–',
    'å®¶åº­å…³ç³»', 'å®¶åº­å†™çœŸ', 'å®¶ç”¨ç”µå™¨å…¶ä»–', 'å®¶çºº', 'å®¿èˆç”Ÿæ´»', 'å¯†å®¤', 'å¯å…·', 'å°å‹å®¶å…·',
    'å°å­¦æ•™è‚²', 'å°è¯­ç§æ•™è‚²', 'å±€éƒ¨å‡è‚¥ç”¨å“', 'å±•ä¼šæ´»åŠ¨', 'å±•ç¤ºåˆé›†', 'å±•è§ˆæ¼”å‡ºå±•ç¤º',
    'å±•è§ˆæ¼”å‡ºæ”»ç•¥', 'å·¥ç¨‹æŠ€æœ¯', 'å¸‚é›†', 'å¸½å­', 'å¹³æ¿', 'å¹³é¢è®¾è®¡', 'å¹³é¢è®¾è®¡å…¶ä»–',
    'å¹¿æ’­å‰§/é…éŸ³', 'åº•å¦†', 'åº—é“ºå®£ä¼ ', 'åº§æ¤…ç±»', 'å»ºç­‘è®¾è®¡', 'å½©å¦†å…¶ä»–', 'å½©å¦†åˆé›†',
    'å½±éŸ³æ™ºèƒ½å…¶ä»–', 'å½±éŸ³ç”µå™¨', 'æ‹çˆ±æŒ‡å—', 'æƒ…ä¾£å†™çœŸ', 'æƒ…æ„Ÿæ—¥å¸¸å…¶ä»–', 'æƒ æ°‘ç”Ÿæ´»',
    'æˆå‰§è¯å‰§', 'æˆ¿è½¦ç”Ÿæ´»', 'æ‰‹åŠå‘¨è¾¹', 'æ‰‹å¥—', 'æ‰‹å·¥æ´»åŠ¨', 'æ‰‹æ‹¿åŒ…', 'æ‰‹æœº', 'æ‰‹æœºå¹³æ¿å…¶ä»–',
    'æ‰‹æœºå¹³æ¿é…ä»¶', 'æ‰‹è¡¨', 'æŠ€æœ¯ç§‘æ™®', 'æŠ•å½±ä»ª', 'æŠ¤è‚¤å…¶ä»–', 'æŠ¤è‚¤åˆé›†', 'æŠ¤è‚¤å·¥å…·',
    'æ‹æ‘„æŠ€å·§', 'æ‹ç…§æŠ€å·§', 'æ‹åŒ…', 'æ‹–é‹', 'æ‹¼è´´è‰ºæœ¯', 'æŒ‘æˆ˜è§†é¢‘', 'æ¢åº—', 'æ‘„å½±å™¨æå…¶ä»–',
    'æ‘„å½±æŠ€å·§å…¶ä»–', 'æ‘©æ‰˜ç”Ÿæ´»', 'æ‘©æ‰˜è£…å¤‡', 'æ‘©æ‰˜è½¦ä»‹ç»', 'æ‘©æ‰˜è½¦å…¶ä»–', 'æ‘©æ‰˜è½¦æ”¹è£…',
    'æ’­æ”¾å™¨', 'æ”€å²©', 'æ”¹è£…å…¶ä»–', 'æ”¹è£…æ”»ç•¥', 'æ”¹è£…æ¡ˆä¾‹', 'æ•™è‚²åŸ¹è®­', 'æ•°å­—è‰ºæœ¯', 'æ•´ä½“å¦†å®¹',
    'æ•´ä½“è£…ä¿®', 'æ•´ä½“é€ å‹', 'æ–‡åˆ›äº§å“', 'æ–‡åŒ–ä½“éªŒ', 'æ–‡åŒ–å…¶ä»–', 'æ–‡å­—ç´ æ', 'æ–‡å­¦è®¨è®º',
    'æ–‡æ•™ä¹¦åº—', 'æ–‡ç‰©å±•', 'æ–‡ç©è—å“', 'æ–°èƒ½æºä»‹ç»', 'æ–°èƒ½æºå…¶ä»–', 'æ–°èƒ½æºæ”¹è£…', 'æ–°èƒ½æºæ”»ç•¥',
    'æ–°èƒ½æºæ—¥å¸¸', 'æ—…å±…å…¶ä»–', 'æ—…æ¸¸æ”»ç•¥å…¶ä»–', 'æ—…è¡Œæ•…äº‹', 'æ—…è¡Œè€…', 'æ—…è¡Œé£å…‰', 'æ— äººæœº',
    'æ— æ™¯ç‚¹VLOG', 'æ—¥å‰§', 'æ—¥å¸¸ç‰‡æ®µå…¶ä»–', 'æ—¥å¸¸è¡¨è¾¾', 'æ—¥è¯­', 'æ—©é¤', 'æ˜†è™«å…¶ä»–', 'æ™’ç‹—',
    'æ™’çŒ«', 'æ™®é€šç¾é£Ÿå±•ç¤º', 'æ™¯ç‚¹å…¶ä»–', 'æ™¯ç‚¹å±•ç¤º', 'æ™¯ç‚¹æ”»ç•¥', 'æ™¯ç‚¹è®°å½•', 'æ™ºèƒ½å®¶ç”µ',
    'æ™ºèƒ½æ‰‹è¡¨æ‰‹ç¯', 'æ™ºèƒ½ç©¿æˆ´', 'æ™ºèƒ½è®¾å¤‡', 'æœ‰è½¦æ—¥å¸¸', 'æœ‹å‹å†™çœŸ', 'æœè£…', 'æœé¥°ç¾å¦†åº—',
    'æ¶ç±»', 'æ ¡å›­å…¶ä»–', 'æ ¡å›­æ´»åŠ¨', 'æ ¡å›­ç¢ç‰‡', 'æ ¡å›­è¶£äº‹', 'æ¡Œå‡ ç±»', 'æ¡Œæ­', 'æ¡Œæ¸¸',
    'æ¤ç‰©ç§‘æ™®', 'æ¨¡ç©æ¨¡å‹', 'æ©±æŸœç±»', 'æ­Œå•åˆ†äº«', 'æ­Œæ›²ç¿»å”±', 'æ­£é¤å…¶ä»–', 'æ°‘å®¿', 'æ°´æœ',
    'æ±‚èŒé¢è¯•', 'æ±‰æœ', 'æ±½è½¦æ”¹è£…', 'æ±½è½¦ç”Ÿæ´»å…¶ä»–', 'æ±½è½¦èµ„è®¯', 'æ³•è¯­', 'æ³›è½¦å…¶ä»–', 'æ³³è£…',
    'æ´é¢', 'æ´—æµ´æŒ‰æ‘©', 'æµ‹è¯„åˆé›†', 'æµ·å¤–VLOG', 'æµ·æŠ¥è®¾è®¡', 'æ¶‚é¸¦', 'æ¸¸ä¹å…', 'æ¸¸æˆè®¾å¤‡',
    'æ¸¸æ³³', 'æ¸¸æ³³æ•™å­¦', 'æ¸¸æ³³çºªå½•', 'æ»‘é›ª', 'æ»‘é›ªåœºåœ°è·¯çº¿', 'æ»‘é›ªè£…å¤‡æœé¥°', 'æ»‘é›ªè®°å½•',
    'æ¼”å”±/ç¿»å”±', 'æ¼”å”±ä¼š', 'æ¼”å”±æ•™å­¦', 'æ¼”å¥/ç¿»å¼¹', 'æ½œæ°´', 'æ½®æµå…¶ä»–é…é¥°', 'æ½®æµå‘å‹',
    'æ½®æµæ‰‹è¡¨', 'æ½®æµæ’ç”»', 'æ½®æµç©å…·', 'æ½®æµç§‘æ™®', 'æ½®æµèµ„è®¯', 'æ½®æµé¦–é¥°', 'ç¯å…·',
    'çƒ˜ç„™&ç”œå“æ•™ç¨‹', 'ç…§ç›¸æœº', 'ç‡ƒè„‚èˆæ•™ç¨‹', 'ç‡ƒè„‚èˆè¯„æµ‹', 'çˆ¬è¡Œä¸¤æ –å…¶ä»–', 'çˆ±æƒ…æ•…äº‹',
    'çˆ±æƒ…æ—¥å¸¸', 'ç‹—å…¶ä»–', 'ç‹—ç”¨å“', 'ç‹—ç±»é£Ÿå“ç”¨å“', 'çŒ«å…¶ä»–', 'çŒ«ç”¨å“', 'çŒ«ç±»é£Ÿå“ç”¨å“',
    'çƒç±»è¿åŠ¨', 'çƒé‹', 'ç‘œä¼½', 'ç‘œä¼½æ•™ç¨‹', 'ç‘œä¼½ç»éªŒç§‘æ™®', 'ç‘œä¼½è£…å¤‡', 'ç‘œä¼½è¯„æµ‹',
    'ç”œå“é¥®å“', 'ç”Ÿå‘½ç§‘å­¦', 'ç”Ÿæ´»å®¶ç”µ', 'ç”Ÿæ´»æ„è¶£', 'ç”Ÿæ´»ç§‘æ™®', 'ç”¨è½¦å¦™æ‹›', 'ç”µå½±å…¶ä»–',
    'ç”µè„‘å¤–è®¾', 'ç”µè„‘æ•´æœº', 'ç”µè§†', 'ç”µè§†å…¶ä»–', 'ç”·æ€§æŠ¤ç†', 'ç•™å­¦æ•™è‚²', 'ç•™å­¦ç”Ÿæ´»',
    'ç•™å­¦ç”³è¯·', 'ç™»å±±å¾’æ­¥', 'ç›¸æœºé…ä»¶', 'çœŸäººæ¼”å”±', 'çœ¼å¦†', 'çœ¼éƒ¨æŠ¤ç†', 'çœ¼é•œ', 'çœ¼éœœ',
    'ç¡¬å¸å¾½ç« ', 'ç¡¬æ ¸è¶Šé‡', 'ç¡¬è£…å»ºæ', 'ç¡¬è£…è®¾è®¡', 'ç§‘æŠ€åŠ¨æ€', 'ç§¯æœ¨', 'ç©¿æ­å…¶ä»–',
    'ç©¿æ­æ•™ç¨‹', 'ç©¿æ­é€ å‹', 'ç¬”è®°æœ¬ç”µè„‘', 'ç®±åŒ…', 'ç®±åŒ…å…¶ä»–', 'ç¯®çƒ', 'ç¯®çƒå…¶ä»–',
    'ç¯®çƒæ•™å­¦', 'ç¯®çƒè®°å½•', 'ç¯®çƒè¯„è¿°', 'ç¯®çƒèµ›äº‹', 'ç²¾å', 'ç³»ç»ŸæŠ€å·§', 'ç´ æåˆ†äº«å…¶ä»–',
    'ç»å…¸ç»˜ç”»', 'ç»¼è‰ºå…¶ä»–', 'ç»¿æ¤', 'ç½‘æ–‡åŠè¡ç”Ÿ', 'ç¾å®¹ç¾å‘åº—', 'è€ƒåš', 'è€ƒç ”', 'è€³æœº',
    'èŒä¸šå²—ä½', 'èŒä¸šèµ„è®¯', 'èŒåœºæŠ€èƒ½', 'èŒåœºæå‡', 'è…°å¸¦', 'è‡ªåˆ¶é›¶é£Ÿ', 'è‡ªæˆ‘å±•ç¤º',
    'è‡ªæˆ‘æˆé•¿', 'è‡ªç„¶é£å…‰', 'è‡ªè€ƒ', 'è‡ªé©¾ç”Ÿæ´»', 'èˆè¹ˆå…¶ä»–', 'èˆè¹ˆç°åœº', 'èˆè¹ˆè¡¨æ¼”/ç¿»è·³',
    'èˆªç©ºèˆªå¤©', 'è‰ºæœ¯å±•', 'è‰ºæœ¯å±•ä¼š', 'èŠ±è‰º', 'è‹±ç¾å‰§', 'è‹±è¯­', 'è‹±è¯­æ•™è‚²', 'èŒ¶',
    'èœå“æ•™ç¨‹', 'è™¾èŸ¹è´èºç±»', 'è›‡', 'è›™', 'èœ¥èœ´', 'è¡Œä¸šèµ„è®¯', 'è¡¨æƒ…åŒ…', 'è£…ä¿®å…¶ä»–',
    'è£…ä¿®æ•™ç¨‹', 'è£…æœºç¡¬ä»¶', 'è£…ç½®è‰ºæœ¯', 'è£…é¥°ç”»', 'è£™å­', 'è£¤å­', 'è§†é¢‘ç´ æ', 'è®ºæ–‡å†™ä½œ',
    'è®ºæ–‡ç­”è¾©', 'è¯ä»¶ç…§', 'è¯—è¯æ­Œèµ‹', 'è¯­è¨€æ•™è‚²', 'è¯­è¨€æ•™è‚²å…¶ä»–', 'è°ƒå‘³å“æ•™ç¨‹', 'è±šé¼ ',
    'è´­ç‰©ä¸­å¿ƒ', 'è´­ç‰©åœ°å…¶ä»–', 'è´­ç‰©åœ°æ”»ç•¥', 'è´­è½¦æ”»ç•¥', 'èµ›è½¦ç‰¹æŠ€', 'è¶…å¸‚', 'è¶Šé‡è·‘',
    'è¶£å‘³äº’åŠ¨', 'è¶³çƒ', 'è¶³çƒå…¶ä»–', 'è¶³çƒæ•™å­¦', 'è¶³çƒè®°å½•', 'è¶³çƒè¯„è¿°', 'è¶³çƒèµ›äº‹',
    'è·‘æ­¥', 'è·‘æ­¥æ•™å­¦', 'è·‘æ­¥è£…å¤‡', 'è·‘æ­¥è®°å½•', 'è·‘æ­¥èµ›äº‹', 'è·¯äºš', 'è·¯è¾¹å°åƒ', 'èº«ä½“æŠ¤ç†',
    'è½¦å†…å¤–è£…é¥°', 'è½¦å‹ç¤¾äº¤', 'è½¦å‹å±•ç¤º', 'è½¦ç‰Œæ”¿ç­–', 'è½¦è½½å¥½ç‰©', 'è½¦è½½å·¥å…·', 'è½®èƒè½®æ¯‚',
    'è½¯ä»¶æŠ€å·§', 'è½¯ä»¶æœåŠ¡å…¶ä»–', 'é€‰è½¦è¯„æµ‹', 'é€Ÿé£Ÿæµ‹è¯„', 'é“è·¯äº¤é€š', 'é…é¥°', 'é…é¥°å…¶ä»–',
    'é…’åº—', 'é’“é±¼å…¶ä»–', 'é’±åŒ…', 'é•¿æ¿', 'é˜…è¯»å…¶ä»–', 'é˜²æ™’', 'é™†å†²', 'éšæ‰‹æ‹', 'é›†å¸‚',
    'é›¶é£Ÿå…¶ä»–', 'é›¶é£Ÿæµ‹è¯„', 'éœ²è¥', 'éœ²è¥æ”»ç•¥', 'éœ²è¥è®°å½•', 'éé…’ç²¾é¥®æ–™å…¶ä»–', 'é¢è†œ',
    'é¢éœœ', 'é¢é£Ÿæ•™ç¨‹', 'é´å­', 'é‹é´å…¶ä»–', 'éŸ©å‰§', 'éŸ©è¯­', 'éŸ³ä¹MV', 'éŸ³ä¹ä¼š', 'éŸ³ä¹å…¶ä»–',
    'éŸ³ä¹å¹•å', 'éŸ³ä¹æ¨è', 'éŸ³ä¹æ¼”å‡ºå…¶ä»–', 'éŸ³ä¹ç°åœº/MV', 'éŸ³ä¹èŠ‚/Livehouse', 'éŸ³ç®±éŸ³å“',
    'é¢†å¸¦é¢†ç»“', 'é£ç›˜è®°å½•', 'é£Ÿæå±•ç¤º', 'é£Ÿææµ‹è¯„', 'é¤å…å…¶ä»–', 'é¤å…æ¢åº—', 'é¤å¨å…·',
    'é¥®å“æ•™ç¨‹', 'é¥®å“æµ‹è¯„', 'é¦–é¥°', 'é©¾è€ƒå­¦è½¦', 'é©¾è€ƒç”Ÿæ´»', 'é©¾é©¶å®‰å…¨', 'é©¾é©¶æŠ€å·§',
    'éª‘è¡Œæ”»ç•¥', 'éª‘è¡Œè®°å½•', 'é­”æœ¯çº¸ç‰Œ', 'é±¼ç±»', 'é±¼ç¼¸é€ æ™¯', 'é¸Ÿç±»å…¶ä»–', 'é¹¦é¹‰', 'é¾™çŒ«', 'é¾Ÿ'
}

VALID_NOTE_MARKETING: Set[str] = {'å•†å“æ¨è', 'ç”Ÿæ´»è®°å½•', 'ç¡¬å¹¿', 'è½¯å¹¿'}


class LLMTaggingService:
    """LLMæ ‡ç­¾é¢„æµ‹æœåŠ¡ - ä½¿ç”¨OpenAI SDK with é‡è¯•æœºåˆ¶"""
    
    def __init__(self):
        """åˆå§‹åŒ–LLMæ ‡ç­¾æœåŠ¡"""
        self.api_key = config.OPENROUTER_API_KEY
        self.model = config.LLM_MODEL
        self.taxonomy = config.load_taxonomy_knowledge()
        
        # é‡è¯•é…ç½®
        self.max_retries = 3
        self.base_delay = 1.0  # åŸºç¡€å»¶è¿Ÿï¼ˆç§’ï¼‰
        self.max_delay = 60.0  # æœ€å¤§å»¶è¿Ÿï¼ˆç§’ï¼‰
        
        # åˆå§‹åŒ–OpenAIå®¢æˆ·ç«¯
        if OPENAI_AVAILABLE and self.api_key:
            self.client = OpenAI(
                base_url="https://openrouter.ai/api/v1",
                api_key=self.api_key,
            )
            logger.info(f"âœ… Initialized OpenAI client for model: {self.model}")
            logger.info(f"OpenAI API key: {self.api_key}") 
        else:
            self.client = None
            if not OPENAI_AVAILABLE:
                logger.warning("OpenAI library not available")
            if not self.api_key:
                logger.warning("OpenRouter API key not configured")
            logger.warning("LLM service will use fallback mode (default tags)")
        
        logger.info(f"LLM tagging service initialized - Retry config: max={self.max_retries}, base_delay={self.base_delay}s")
    
    def _build_prompt(self, note: NoteInput) -> str:
        """æ„å»ºLLMæç¤ºè¯ - ä½¿ç”¨ä¸¥æ ¼çš„è¯è¡¨çº¦æŸ"""
        # å°†è¯è¡¨è½¬æ¢ä¸ºæ’åºåˆ—è¡¨ç”¨äºprompt
        intention_lv1_list = sorted(VALID_INTENTION_LV1)
        intention_lv2_list = sorted(VALID_INTENTION_LV2)
        taxonomy1_list = sorted(VALID_TAXONOMY1)
        taxonomy2_list = sorted(VALID_TAXONOMY2)
        taxonomy3_list = sorted(VALID_TAXONOMY3)
        marketing_list = sorted(VALID_NOTE_MARKETING)

        prompt = f"""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å°çº¢ä¹¦å†…å®¹åˆ†ç±»åŠ©æ‰‹ã€‚è¯·æ ¹æ®ç¬”è®°çš„æ ‡é¢˜å’Œå†…å®¹ï¼Œä¸ºå…¶é€‰æ‹©æœ€åˆé€‚çš„åˆ†ç±»æ ‡ç­¾ã€‚

ã€é‡è¦ã€‘ä½ å¿…é¡»ä¸¥æ ¼ä»ç»™å®šçš„ç±»åˆ«åˆ—è¡¨ä¸­é€‰æ‹©ï¼Œä¸èƒ½è‡ªå·±ç¼–é€ ç±»åˆ«ã€‚å¦‚æœæ²¡æœ‰å®Œå…¨åŒ¹é…çš„ç±»åˆ«ï¼Œè¯·é€‰æ‹©æœ€æ¥è¿‘çš„ä¸€ä¸ªã€‚

ç¬”è®°ä¿¡æ¯ï¼š
æ ‡é¢˜ï¼š{note.title}
å†…å®¹ï¼š{note.content[:500]}

è¯·ä¸ºä»¥ä¸‹6ä¸ªç»´åº¦å„é€‰æ‹©ä¸€ä¸ªæœ€åˆé€‚çš„ç±»åˆ«ï¼š

1. intention_lv1ï¼ˆä¸€çº§æ„å›¾ï¼‰- å¿…é¡»ä»ä»¥ä¸‹{len(intention_lv1_list)}ä¸ªé€‰é¡¹ä¸­é€‰æ‹©ï¼š
{', '.join(intention_lv1_list)}

2. intention_lv2ï¼ˆäºŒçº§æ„å›¾ï¼‰- å¿…é¡»ä»ä»¥ä¸‹{len(intention_lv2_list)}ä¸ªé€‰é¡¹ä¸­é€‰æ‹©ï¼š
{', '.join(intention_lv2_list)}

3. taxonomy1ï¼ˆä¸€çº§åˆ†ç±»ï¼‰- å¿…é¡»ä»ä»¥ä¸‹{len(taxonomy1_list)}ä¸ªé€‰é¡¹ä¸­é€‰æ‹©ï¼š
{', '.join(taxonomy1_list)}

4. taxonomy2ï¼ˆäºŒçº§åˆ†ç±»ï¼‰- å¿…é¡»ä»ä»¥ä¸‹{len(taxonomy2_list)}ä¸ªé€‰é¡¹ä¸­é€‰æ‹©ï¼š
{', '.join(taxonomy2_list)}

5. taxonomy3ï¼ˆä¸‰çº§åˆ†ç±»ï¼‰- å¿…é¡»ä»ä»¥ä¸‹{len(taxonomy3_list)}ä¸ªé€‰é¡¹ä¸­é€‰æ‹©ï¼š
{', '.join(taxonomy3_list)}

6. note_marketing_integrated_levelï¼ˆå†…å®¹è¥é”€æ„Ÿï¼‰- å¿…é¡»ä»ä»¥ä¸‹{len(marketing_list)}ä¸ªé€‰é¡¹ä¸­é€‰æ‹©ï¼š
{', '.join(marketing_list)}

è¯·ä»¥JSONæ ¼å¼è¿”å›ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š
{{
    "intention_lv1": "ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„æ ‡ç­¾",
    "intention_lv2": "ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„æ ‡ç­¾",
    "taxonomy1": "ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„æ ‡ç­¾",
    "taxonomy2": "ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„æ ‡ç­¾",
    "taxonomy3": "ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„æ ‡ç­¾",
    "note_marketing_integrated_level": "ä»åˆ—è¡¨ä¸­é€‰æ‹©çš„æ ‡ç­¾"
}}

æ³¨æ„ï¼š
- æ¯ä¸ªå­—æ®µçš„å€¼å¿…é¡»æ˜¯ä¸Šé¢å¯¹åº”åˆ—è¡¨ä¸­çš„æŸä¸€é¡¹ï¼Œä¸èƒ½æ˜¯å…¶ä»–å€¼
- å¦‚æœå®åœ¨æ²¡æœ‰åˆé€‚çš„ï¼Œé€‰æ‹©æœ€æ¥è¿‘çš„ä¸€ä¸ªï¼Œä¸è¦ç•™ç©º
- åªè¿”å›JSONï¼Œä¸è¦æœ‰å…¶ä»–è¯´æ˜
"""
        return prompt
    
    async def predict_tags(self, note: NoteInput) -> TagPrediction:
        """
        é¢„æµ‹ç¬”è®°çš„æ ‡ç­¾ - ä½¿ç”¨OpenAI SDK with é‡è¯•æœºåˆ¶
        
        Args:
            note: ç¬”è®°è¾“å…¥
            
        Returns:
            æ ‡ç­¾é¢„æµ‹ç»“æœ
        """
        start_time = time.time()
        logger.info(f"ğŸ·ï¸ Starting LLM tag prediction for note: {note.note_id or 'unnamed'}")
        
        # å¦‚æœå®¢æˆ·ç«¯ä¸å¯ç”¨ï¼Œç›´æ¥è¿”å›é»˜è®¤æ ‡ç­¾
        if not self.client:
            logger.warning("LLM client not available, using default tags")
            return self._get_default_tags()
        
        # æ„å»ºprompt
        prompt = self._build_prompt(note)
        
        # æ‰“å°è¯¦ç»†çš„promptä¿¡æ¯
        logger.info("=" * 60)
        logger.info("ğŸ“ LLM PROMPT")
        logger.info("=" * 60)
        logger.info(f"Model: {self.model}")
        logger.info(f"Note ID: {note.note_id}")
        logger.info(f"Title: {note.title}")
        logger.info(f"Content: {note.content[:200]}...")
        #logger.info("--- Full Prompt ---")
        #logger.info(prompt)
        logger.info("=" * 60)
        
        # è¿›è¡Œé‡è¯•è°ƒç”¨
        for attempt in range(self.max_retries + 1):
            try:
                logger.info(f"ğŸ”„ LLM API call attempt {attempt + 1}/{self.max_retries + 1}")
                
                # è°ƒç”¨OpenAI API
                response = await self._call_openai_api(prompt)
                
                # è§£æå“åº”
                result = self._parse_llm_response(response)
                
                # è®°å½•æˆåŠŸä¿¡æ¯
                elapsed_time = time.time() - start_time
                #logger.info(f"âœ… LLM tag prediction successful in {elapsed_time:.2f}s after {attempt + 1} attempts")
                
                return result
                
            except Exception as e:
                error_type = type(e).__name__
                
                # æ£€æŸ¥æ˜¯å¦æ˜¯å¯é‡è¯•çš„é”™è¯¯
                if self._is_retryable_error(e) and attempt < self.max_retries:
                    delay = self._calculate_backoff_delay(attempt)
                    logger.warning(f"âš ï¸ LLM API call failed ({error_type}: {e}), retrying in {delay:.1f}s...")
                    await asyncio.sleep(delay)
                    continue
                else:
                    # æœ€ç»ˆå¤±è´¥æˆ–ä¸å¯é‡è¯•çš„é”™è¯¯
                    elapsed_time = time.time() - start_time
                    logger.error(f"âŒ LLM tag prediction failed after {attempt + 1} attempts in {elapsed_time:.2f}s")
                    logger.error(f"Final error: {error_type}: {e}")
                    return self._get_default_tags()
        
        # åº”è¯¥ä¸ä¼šåˆ°è¾¾è¿™é‡Œï¼Œä½†ä¸ºäº†å®‰å…¨
        return self._get_default_tags()
    
    async def _call_openai_api(self, prompt: str) -> str:
        """è°ƒç”¨OpenAI API"""
        try:
            completion = self.client.chat.completions.create(
                extra_headers={
                    "HTTP-Referer": "https://github.com/xhs-ctr-project",
                    "X-Title": "XHS Content Tagging",
                },
                extra_body={},
                model=self.model,
                messages=[
                    {"role": "system", "content": "You are a helpful assistant that classifies content accurately. Return only valid JSON."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.1,
                max_tokens=500,
                timeout=30.0
            )
            
            # è·å–å“åº”å†…å®¹
            content = completion.choices[0].message.content
            
            # æ‰“å°è¯¦ç»†çš„å“åº”ä¿¡æ¯
            logger.info("=" * 60)
            logger.info("ğŸ“¨ LLM RESPONSE")
            logger.info("=" * 60)
            #logger.info(f"Model: {completion.model}")
            #logger.info(f"Usage: {completion.usage}")
            #logger.info(f"Finish reason: {completion.choices[0].finish_reason}")
            logger.info("--- Response Content ---")
            logger.info(content)
            logger.info("=" * 60)
            
            return content
            
        except Exception as e:
            logger.error(f"OpenAI API call failed: {type(e).__name__}: {e}")
            raise
    
    def _parse_llm_response(self, content: str) -> TagPrediction:
        """è§£æLLMå“åº”å†…å®¹å¹¶éªŒè¯ä¿®æ­£æ ‡ç­¾"""
        try:
            # æ¸…ç†å¯èƒ½çš„markdownä»£ç å—æ ‡è®°
            if '```json' in content:
                content = content.split('```json')[1].split('```')[0]
            elif '```' in content:
                content = content.split('```')[1].split('```')[0]

            # è§£æJSON
            tags_dict = json.loads(content.strip())

            # åˆ›å»ºTagPredictionå¯¹è±¡
            raw_result = TagPrediction(
                intention_lv1=tags_dict.get('intention_lv1', ''),
                intention_lv2=tags_dict.get('intention_lv2', ''),
                taxonomy1=tags_dict.get('taxonomy1', ''),
                taxonomy2=tags_dict.get('taxonomy2', ''),
                taxonomy3=tags_dict.get('taxonomy3', ''),
                note_marketing_integrated_level=tags_dict.get('note_marketing_integrated_level', '')
            )

            # éªŒè¯å¹¶ä¿®æ­£æ ‡ç­¾ï¼Œç¡®ä¿éƒ½åœ¨æœ‰æ•ˆè¯è¡¨ä¸­
            validated_result = self._validate_and_correct_tags(raw_result)

            logger.info(f"ğŸ“Š Validated tags: {validated_result.dict()}")
            return validated_result

        except json.JSONDecodeError as e:
            logger.error(f"Failed to parse LLM response as JSON: {e}")
            logger.error(f"Raw content: {content}")
            raise ValueError(f"Invalid JSON response: {e}")
        except Exception as e:
            logger.error(f"Failed to parse LLM response: {e}")
            raise
    
    def _is_retryable_error(self, error: Exception) -> bool:
        """åˆ¤æ–­é”™è¯¯æ˜¯å¦å¯é‡è¯•"""
        error_message = str(error).lower()
        
        # å¯é‡è¯•çš„é”™è¯¯ç±»å‹
        retryable_errors = [
            '429',  # Too Many Requests
            'too many requests',
            'rate limit',
            'timeout',
            'connection',
            'temporary',
            'server error',
            '500',
            '502',
            '503',
            '504'
        ]
        
        for retryable in retryable_errors:
            if retryable in error_message:
                return True
        
        return False
    
    def _calculate_backoff_delay(self, attempt: int) -> float:
        """è®¡ç®—æŒ‡æ•°é€€é¿å»¶è¿Ÿ"""
        # æŒ‡æ•°é€€é¿ï¼šbase_delay * 2^attempt + éšæœºæŠ–åŠ¨
        delay = self.base_delay * (2 ** attempt)
        
        # æ·»åŠ éšæœºæŠ–åŠ¨ï¼ˆé¿å…åŒæ—¶é‡è¯•ï¼‰
        jitter = random.uniform(0, delay * 0.1)
        delay += jitter
        
        # é™åˆ¶æœ€å¤§å»¶è¿Ÿ
        delay = min(delay, self.max_delay)
        
        return delay
    
    def _get_default_tags(self) -> TagPrediction:
        """è·å–é»˜è®¤æ ‡ç­¾ï¼ˆç”¨äºé”™è¯¯æƒ…å†µæˆ–æµ‹è¯•ï¼‰"""
        return TagPrediction(
            intention_lv1="åˆ†äº«",
            intention_lv2="åˆ†äº«æ—¥å¸¸",
            taxonomy1="ç”Ÿæ´»è®°å½•",
            taxonomy2="",
            taxonomy3="",
            note_marketing_integrated_level="ç”Ÿæ´»è®°å½•"
        )
    
    def _validate_and_correct_tags(self, tags: TagPrediction) -> TagPrediction:
        """
        éªŒè¯å¹¶ä¿®æ­£æ ‡ç­¾ - ç¡®ä¿æ‰€æœ‰æ ‡ç­¾éƒ½åœ¨æœ‰æ•ˆè¯è¡¨ä¸­

        Args:
            tags: åŸå§‹æ ‡ç­¾é¢„æµ‹ç»“æœ

        Returns:
            ä¿®æ­£åçš„æ ‡ç­¾
        """
        corrected = {}
        invalid_found = []

        # éªŒè¯æ¯ä¸ªå­—æ®µ
        field_vocab_map = {
            'intention_lv1': (tags.intention_lv1, VALID_INTENTION_LV1, 'åˆ†äº«'),
            'intention_lv2': (tags.intention_lv2, VALID_INTENTION_LV2, 'åˆ†äº«æ—¥å¸¸'),
            'taxonomy1': (tags.taxonomy1, VALID_TAXONOMY1, 'ç”Ÿæ´»è®°å½•'),
            'taxonomy2': (tags.taxonomy2, VALID_TAXONOMY2, ''),
            'taxonomy3': (tags.taxonomy3, VALID_TAXONOMY3, ''),
            'note_marketing_integrated_level': (tags.note_marketing_integrated_level, VALID_NOTE_MARKETING, 'ç”Ÿæ´»è®°å½•'),
        }

        for field_name, (value, valid_set, default) in field_vocab_map.items():
            if value and value in valid_set:
                corrected[field_name] = value
            elif value:
                # å€¼ä¸åœ¨æœ‰æ•ˆè¯è¡¨ä¸­ï¼Œå°è¯•æ‰¾æœ€æ¥è¿‘çš„
                closest = self._find_closest_match(value, valid_set)
                if closest:
                    invalid_found.append(f"{field_name}: '{value}' -> '{closest}'")
                    corrected[field_name] = closest
                else:
                    invalid_found.append(f"{field_name}: '{value}' -> default '{default}'")
                    corrected[field_name] = default
            else:
                corrected[field_name] = default

        if invalid_found:
            logger.warning(f"âš ï¸ LLMè¾“å‡ºäº†æ— æ•ˆç±»åˆ«ï¼Œå·²è‡ªåŠ¨ä¿®æ­£: {invalid_found}")

        return TagPrediction(**corrected)

    def _find_closest_match(self, value: str, valid_set: Set[str]) -> Optional[str]:
        """
        æŸ¥æ‰¾æœ€æ¥è¿‘çš„åŒ¹é…é¡¹ï¼ˆç®€å•çš„åŒ…å«åŒ¹é…ï¼‰

        Args:
            value: å¾…åŒ¹é…çš„å€¼
            valid_set: æœ‰æ•ˆå€¼é›†åˆ

        Returns:
            æœ€æ¥è¿‘çš„åŒ¹é…é¡¹ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°è¿”å›None
        """
        if not value or not valid_set:
            return None

        value_lower = value.lower()

        # ç²¾ç¡®åŒ¹é…ï¼ˆå¿½ç•¥å¤§å°å†™ï¼‰
        for item in valid_set:
            if item.lower() == value_lower:
                return item

        # åŒ…å«åŒ¹é…
        for item in valid_set:
            if value in item or item in value:
                return item

        # éƒ¨åˆ†è¯åŒ¹é…ï¼ˆåˆ†è¯ååŒ¹é…ï¼‰
        value_parts = set(value.replace('/', '').replace('&', ''))
        for item in valid_set:
            item_parts = set(item.replace('/', '').replace('&', ''))
            # å¦‚æœæœ‰å…¬å…±å­—ç¬¦è¶…è¿‡ä¸€åŠ
            common = len(value_parts & item_parts)
            if common > len(value_parts) * 0.5:
                return item

        return None

    def validate_tags(self, tags: TagPrediction) -> bool:
        """
        éªŒè¯æ ‡ç­¾æ˜¯å¦å…¨éƒ¨æœ‰æ•ˆ

        Args:
            tags: æ ‡ç­¾é¢„æµ‹ç»“æœ

        Returns:
            æ˜¯å¦å…¨éƒ¨æœ‰æ•ˆ
        """
        checks = [
            (tags.intention_lv1 in VALID_INTENTION_LV1 or not tags.intention_lv1),
            (tags.intention_lv2 in VALID_INTENTION_LV2 or not tags.intention_lv2),
            (tags.taxonomy1 in VALID_TAXONOMY1 or not tags.taxonomy1),
            (tags.taxonomy2 in VALID_TAXONOMY2 or not tags.taxonomy2),
            (tags.taxonomy3 in VALID_TAXONOMY3 or not tags.taxonomy3),
            (tags.note_marketing_integrated_level in VALID_NOTE_MARKETING or not tags.note_marketing_integrated_level),
        ]
        return all(checks)